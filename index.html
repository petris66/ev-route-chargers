<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <title>EV Route Charger Finder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #map { height: 45vh; }
    main { padding: 10px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .grow { flex: 1; min-width: 220px; }
    button { padding: 9px 12px; border-radius: 10px; border: none; cursor: pointer; }
    .primary { background: #2563eb; color: #fff; }
    .secondary { background: #0f172a; color: #fff; }
    .ghost { background: #f1f5f9; color: #0f172a; }
    .pill { background: #f1f5f9; padding: 6px 10px; border-radius: 999px; font-size: 14px; display:flex; gap:8px; align-items:center;}
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 10px; margin-bottom: 8px; }
    .meta { display: flex; gap: 6px; flex-wrap: wrap; font-size: 13px; margin-top:6px;}
    .small { font-size: 13px; }
    .warn { color: #b45309; }
    .error { color: #b91c1c; }
    input { padding: 9px 10px; border: 1px solid #e5e7eb; border-radius: 10px; }
    .pill input { padding: 4px 6px; border-radius: 8px; }
    #debug { margin-top:10px; white-space:pre-wrap; background:#f8fafc; padding:10px; border-radius:12px; border:1px solid #e5e7eb; max-height: 180px; overflow:auto; display:none; }
    .muted { color:#64748b; }
    label.chk { display:flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; background:#f1f5f9; font-size:14px; }
    label.chk input { width:18px; height:18px; }
  </style>
</head>
<body>

<div id="map"></div>

<main>
  <div class="row">
    <input id="fromCity" class="grow" placeholder="Lähtökaupunki (jos GPS ei toimi)" autocomplete="street-address"/>
    <input id="toCity" class="grow" placeholder="Määränpää (esim. Turku)" autocomplete="street-address"/>
  </div>

  <div class="row" style="margin-top:8px;">
    <label class="pill">
      Akkua (km)
      <input id="rangeKm" type="number" inputmode="numeric" value="140" style="width:92px;">
    </label>

    <label class="pill">
      Vara (km)
      <input id="bufferKm" type="number" inputmode="numeric" value="20" style="width:82px;">
    </label>

    <label class="pill">
      Hakusäde (km)
      <input id="nextRadiusKm" type="number" inputmode="numeric" value="40" style="width:82px;">
    </label>

    <label class="pill">
      Min. teho (kW)
      <input id="minKw" type="number" inputmode="numeric" value="150" style="width:82px;">
    </label>

    <label class="chk" title="Suodattaa AC/type2 pois ja näyttää vain DC-pikalatauksen">
      <input id="dcOnly" type="checkbox" checked>
      Vain DC pikalataus
    </label>

    <button id="btnNextCharge" class="primary">Etsi seuraava latauspaikka</button>
    <button id="btnUseGPS" class="ghost" title="Tyhjentää lähtökentän ja käyttää GPS:ää jos sallittu">Käytä GPS-lähtöä</button>
    <button id="btnHardReload" class="ghost" title="Jos iPhone näyttää vanhaa versiota">Päivitä “kovaa”</button>
  </div>

  <div class="row" style="margin-top:8px;">
    <input id="ocmKey" class="grow" placeholder="Open Charge Map API key (tallentuu laitteeseen)">
    <button id="btnToggleDebug" class="secondary">Debug</button>
  </div>

  <div class="small muted" style="margin-top:4px;">
    Laskenta: <b>seuraava lataus (km) = akkua − vara (km)</b>. Kylmällä kelillä nosta varaa.
  </div>

  <div id="status" class="small" style="margin-top:8px;"></div>
  <div id="list" style="margin-top:10px;"></div>

  <pre id="debug" class="small"></pre>
</main>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ------------------ DEBUG ------------------ */
const elDebug = document.getElementById("debug");
function dbg(...args) {
  const line = args.map(a => {
    if (typeof a === "string") return a;
    try { return JSON.stringify(a); } catch { return String(a); }
  }).join(" ");
  elDebug.textContent += line + "\n";
  elDebug.scrollTop = elDebug.scrollHeight;
}
window.addEventListener("error", (e) => dbg("JS ERROR:", e.message));
window.addEventListener("unhandledrejection", (e) => dbg("PROMISE ERROR:", String(e.reason)));

/* ------------------ MAP ------------------ */
const map = L.map('map', { zoomControl: true }).setView([60.1699, 24.9384], 6);

const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18,
  attribution: '&copy; OpenStreetMap'
}).addTo(map);

tiles.on('tileerror', (e) => dbg("TILE ERROR (OSM):", e?.error?.message || "tileerror"));

// featureGroup => getBounds() toimii
const markersLayer = L.featureGroup().addTo(map);

/* ------------------ ELEMENTS ------------------ */
const elFromCity = document.getElementById('fromCity');
const elToCity = document.getElementById('toCity');
const elRangeKm = document.getElementById('rangeKm');
const elBufferKm = document.getElementById('bufferKm');
const elNextRadiusKm = document.getElementById('nextRadiusKm');
const elMinKw = document.getElementById('minKw');
const elDcOnly = document.getElementById('dcOnly');
const elBtnNextCharge = document.getElementById('btnNextCharge');
const elStatus = document.getElementById('status');
const elList = document.getElementById('list');
const elKey = document.getElementById('ocmKey');
const elBtnToggleDebug = document.getElementById('btnToggleDebug');
const elBtnHardReload = document.getElementById('btnHardReload');
const elBtnUseGPS = document.getElementById('btnUseGPS');

/* ------------------ OCM KEY: localStorage ------------------ */
const OCM_KEY_STORAGE = "ocm_api_key";
try {
  const saved = localStorage.getItem(OCM_KEY_STORAGE);
  if (saved) elKey.value = saved;
} catch (e) {
  dbg("localStorage read failed:", e?.message || String(e));
}
elKey.addEventListener("input", () => {
  try {
    const v = elKey.value.trim();
    if (v) localStorage.setItem(OCM_KEY_STORAGE, v);
    else localStorage.removeItem(OCM_KEY_STORAGE);
  } catch (e) {
    dbg("localStorage write failed:", e?.message || String(e));
  }
});

elBtnToggleDebug.addEventListener("click", () => {
  const show = elDebug.style.display !== "block";
  elDebug.style.display = show ? "block" : "none";
  if (show) dbg("Debug ON —", new Date().toISOString());
});

elBtnHardReload.addEventListener("click", () => {
  const u = new URL(location.href);
  u.searchParams.set("v", String(Date.now()));
  location.replace(u.toString());
});

elBtnUseGPS.addEventListener("click", async () => {
  elFromCity.value = "";
  setStatus("OK — käytetään GPS-lähtöä (jos lupa sallittu). Paina nyt 'Etsi seuraava latauspaikka'.");
});

/* ------------------ NETWORK: fetch + timeout ------------------ */
async function fetchJsonWithTimeout(url, options = {}, timeoutMs = 12000) {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);

  dbg("FETCH START", timeoutMs + "ms", url);

  try {
    const r = await fetch(url, { ...options, signal: controller.signal });

    // Jos päästiin tänne asti, saatiin HTTP-vastaus
    const text = await r.text();
    dbg("HTTP", r.status, url);

    if (!r.ok) throw new Error(`HTTP ${r.status}: ${text.slice(0, 180)}`);
    if (!text) return null;
    return JSON.parse(text);

  } catch (e) {
    if (e?.name === "AbortError") {
      // Nyt tiedetään varmasti mikä kutsu timeouttasi
      throw new Error(`Timeout (${timeoutMs}ms): ${url}`);
    }
    throw e;
  } finally {
    clearTimeout(t);
  }
}


/* ------------------ HELPERS ------------------ */
function setStatus(msg, cls) {
  elStatus.className = "small " + (cls || "");
  elStatus.textContent = msg;
  dbg("STATUS:", msg);
}

function haversineKm(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2-lat1) * Math.PI/180;
  const dLon = (lon2-lon1) * Math.PI/180;
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1*Math.PI/180) *
    Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

async function geocode(placeName) {
  const url =
    "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" +
    encodeURIComponent(placeName);

  const j = await fetchJsonWithTimeout(url, { headers: { "Accept": "application/json" } }, 12000);
  if (!j || !j[0]) return null;

  return { lat: +j[0].lat, lon: +j[0].lon, label: placeName };
}

async function getStartLocationOrFallback() {
  return new Promise(resolve => {
    if (!navigator.geolocation) return resolve(null);

    navigator.geolocation.getCurrentPosition(
      p => resolve({
        lat: p.coords.latitude,
        lon: p.coords.longitude,
        label: "Nykyinen sijainti"
      }),
      err => {
        dbg("GEOLOCATION ERROR:", err?.message || String(err));
        resolve(null);
      },
      { enableHighAccuracy: true, timeout: 8000, maximumAge: 60000 }
    );
  });
}

async function fetchRouteOSRM(start, end) {
  const url =
    `https://router.project-osrm.org/route/v1/driving/` +
    `${start.lon},${start.lat};${end.lon},${end.lat}?overview=full&geometries=geojson`;

  const j = await fetchJsonWithTimeout(url, {}, 12000);
  const coords = j?.routes?.[0]?.geometry?.coordinates;

  if (!coords || !Array.isArray(coords) || coords.length < 2) {
    throw new Error("OSRM: reittiä ei löytynyt");
  }
  return coords;
}

function pointAlongRoute(coords, targetKm) {
  let acc = 0;
  for (let i=1; i<coords.length; i++) {
    const a = coords[i-1], b = coords[i];
    const d = haversineKm(a[1], a[0], b[1], b[0]);
    if (acc + d >= targetKm) {
      const t = d === 0 ? 0 : (targetKm - acc) / d;
      return { lat: a[1] + (b[1]-a[1]) * t, lon: a[0] + (b[0]-a[0]) * t };
    }
    acc += d;
  }
  const last = coords[coords.length-1];
  return { lat:last[1], lon:last[0] };
}

function isDcConnection(c) {
  const level = Number(c?.LevelID) || 0;
  const currentTitle = (c?.CurrentType?.Title || "").toUpperCase();
  return level === 3 || currentTitle.includes("DC");
}

function maxPowerKw(poi, dcOnly) {
  const conns = poi?.Connections || [];
  let maxKw = 0;

  for (const c of conns) {
    if (dcOnly && !isDcConnection(c)) continue;

    const kw = Number(c?.PowerKW) || 0;
    const amps = Number(c?.Amps) || 0;
    const volts = Number(c?.Voltage) || 0;
    const inferred = (amps && volts) ? (amps * volts / 1000) : 0;

    maxKw = Math.max(maxKw, kw, inferred);
  }
  return maxKw;
}

async function fetchOCM({lat, lon, km, key}) {
  const p = new URLSearchParams({
    latitude: String(lat),
    longitude: String(lon),
    distance: String(km),
    distanceunit: "KM",
    maxresults: "100",
    key: key || ""
  });

  const url = "https://api.openchargemap.io/v3/poi/?" + p.toString();
 return await fetchJsonWithTimeout(url, { headers: { "Accept": "application/json" } }, 30000);
}

function addPin(lat, lon, labelHtml, color) {
  return L.circleMarker([lat, lon], {
    radius: 7,
    color,
    fillColor: color,
    fillOpacity: 0.95
  }).addTo(markersLayer).bindPopup(labelHtml);
}

function safeFitBounds() {
  if (markersLayer.getLayers().length > 0) {
    map.fitBounds(markersLayer.getBounds(), { padding: [20,20] });
  }
}

/* ------------------ MAIN LOGIC ------------------ */
elBtnNextCharge.addEventListener('click', async () => {
  markersLayer.clearLayers();
  elList.innerHTML = "";
  elStatus.textContent = "";

  const rangeKm = Number(elRangeKm.value);
  const bufferKm = Number(elBufferKm.value);
  const radiusKm = Number(elNextRadiusKm.value);
  const minKw = Number(elMinKw.value);
  const dcOnly = !!elDcOnly.checked;

  const toName = elToCity.value.trim();
  const fromFallback = elFromCity.value.trim();
  const key = elKey.value.trim();

  if (!toName) return setStatus("Anna määränpää.", "warn");
  if (!Number.isFinite(rangeKm) || rangeKm <= 0) return setStatus("Tarkista 'Akkua (km)'.", "warn");
  if (!Number.isFinite(bufferKm) || bufferKm < 0) return setStatus("Tarkista 'Vara (km)'.", "warn");
  if (!Number.isFinite(radiusKm) || radiusKm <= 0) return setStatus("Tarkista 'Hakusäde (km)'.", "warn");
  if (!Number.isFinite(minKw) || minKw < 0) return setStatus("Tarkista 'Min. teho (kW)'.", "warn");

  const needKm = Math.max(0, rangeKm - bufferKm);
  dbg("Computed needKm:", needKm, "from range/buffer", rangeKm, bufferKm);

  if (needKm <= 0) {
    return setStatus("Akkua − vara = 0 km. Pienennä varaa tai syötä suurempi akkumatka.", "warn");
  }

  try {
    setStatus("Haetaan lähtö ja määränpää…");

    let start = await getStartLocationOrFallback();
    if (!start) {
      if (!fromFallback) {
        setStatus("GPS ei käytettävissä – anna lähtökaupunki (tai salli sijainti).", "warn");
        return;
      }
      start = await geocode(fromFallback);
    }

    const to = await geocode(toName);

    if (!start || !to) {
      setStatus("Geokoodaus epäonnistui. Kokeile esim. 'Helsinki, Finland' / 'Turku, Finland'.", "error");
      return;
    }

    setStatus("Haetaan reitti…");
    const route = await fetchRouteOSRM(start, to);

    L.geoJSON({ type: "LineString", coordinates: route }, { color: "#2563eb", weight: 4 })
      .addTo(markersLayer);

    addPin(start.lat, start.lon, `<b>Lähtö</b><br>${start.label}`, "#0f172a");
    addPin(to.lat, to.lon, `<b>Määränpää</b><br>${to.label}`, "#7c3aed");

    const target = pointAlongRoute(route, needKm);
    addPin(
      target.lat,
      target.lon,
      `<b>Seuraava lataus</b><br>${needKm.toFixed(0)} km (akkua ${rangeKm} − vara ${bufferKm})`,
      "#f59e0b"
    );

    setStatus("Haetaan latauspisteet…");

    if (!key) {
      setStatus("Lisää Open Charge Map API key (tallentuu laitteeseen).", "warn");
      safeFitBounds();
      return;
    }

    const pois = await fetchOCM({ lat: target.lat, lon: target.lon, km: radiusKm, key });

    const mapped = (pois || []).map(p => {
      const ai = p?.AddressInfo || {};
      const lat = Number(ai?.Latitude);
      const lon = Number(ai?.Longitude);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;

      const title = ai?.Title || ai?.AddressLine1 || "Nimetön latauspaikka";
      const maxPower = maxPowerKw(p, dcOnly);
      const dist = haversineKm(target.lat, target.lon, lat, lon);
      return { title, lat, lon, maxPower, dist };
    }).filter(Boolean);

    // 1) ensisijainen: minKw
    let results = mapped
      .filter(x => x.maxPower >= minKw)
      .sort((a,b) => (b.maxPower - a.maxPower) || (a.dist - b.dist))
      .slice(0, 5);

    // 2) fallback: jos ei löydy, näytä parhaat saatavilla
    let usedFallback = false;
    if (results.length === 0) {
      usedFallback = true;
      results = mapped
        .filter(x => x.maxPower > 0)
        .sort((a,b) => (b.maxPower - a.maxPower) || (a.dist - b.dist))
        .slice(0, 5);
    }

    if (results.length === 0) {
      setStatus(`Ei löytynyt sopivia latauspisteitä (DCOnly=${dcOnly ? "kyllä" : "ei"}) säteellä ${radiusKm} km. Kokeile isompaa säteyttä tai ota DCOnly pois.`, "warn");
      safeFitBounds();
      return;
    }

    results.forEach(r => {
      L.circleMarker([r.lat, r.lon], {
        radius: 8,
        color: "green",
        fillColor: "green",
        fillOpacity: 0.9
      }).addTo(markersLayer)
        .bindPopup(`<b>${r.title}</b><br>${Math.round(r.maxPower)} kW<br>${r.dist.toFixed(1)} km`);

      const card = document.createElement("div");
      card.className = "card";
      card.innerHTML = `
        <b>${r.title}</b>
        <div class="meta">
          <span class="pill">${Math.round(r.maxPower)} kW</span>
          <span class="pill">${r.dist.toFixed(1)} km</span>
          <span class="pill">Target: ${needKm.toFixed(0)} km</span>
        </div>
        <button class="primary" style="margin-top:8px;">Navigoi</button>
      `;

      card.querySelector("button").onclick = () => {
        window.open(
          `https://www.google.com/maps/dir/?api=1&destination=${r.lat},${r.lon}`,
          "_blank"
        );
      };

      elList.appendChild(card);
    });

    safeFitBounds();

    if (usedFallback) {
      setStatus(`Ei löytynyt ≥${minKw} kW (${dcOnly ? "vain DC" : "DC/AC"}) säteellä ${radiusKm} km — näytetään parhaat saatavilla olevat (${results.length} kpl).`, "warn");
    } else {
      setStatus(`Löytyi ${results.length} parasta ≥${minKw} kW (${dcOnly ? "vain DC" : "DC/AC"}) latauspaikkaa.`);
    }

  } catch (e) {
    const msg = e?.name === "AbortError"
      ? "Aikakatkaisu: palvelu ei vastannut ajoissa (kokeile uudestaan / eri verkko)."
      : (e?.message || String(e));

    dbg("CATCH:", msg);
    setStatus("Haku epäonnistui: " + msg, "error");
  }
});

dbg("App loaded:", location.href);
</script>
</body>
</html>
