<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HPC Finder</title>
  <meta name="theme-color" content="#111111" />
  <link rel="manifest" href="manifest.webmanifest">

  <!-- Leaflet (kartta) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0b0b; color: #f2f2f2; }
    header { padding: 12px 14px; background: #111; position: sticky; top: 0; z-index: 10; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    input, button, select { font-size: 16px; padding: 10px; border-radius: 10px; border: 1px solid #333; background: #151515; color: #f2f2f2; }
    button { cursor: pointer; }
    button.primary { background: #2563eb; border-color: #2563eb; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .small { font-size: 12px; opacity: .85; }
    #map { height: 46vh; width: 100%; }
    main { padding: 10px 14px 16px; }
    .panel { background: #111; border: 1px solid #222; border-radius: 14px; padding: 12px; margin-top: 10px; }
    .list { display: grid; gap: 10px; margin-top: 10px; }
    .card { background: #111; border: 1px solid #222; border-radius: 14px; padding: 12px; }
    .card h3 { margin: 0 0 6px; font-size: 16px; }
    .meta { display: flex; gap: 10px; flex-wrap: wrap; font-size: 13px; opacity: .9; }
    .pill { padding: 3px 8px; border: 1px solid #2a2a2a; border-radius: 999px; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    .warn { color: #ffd166; }
    .error { color: #ff6b6b; }
    label { display: flex; gap: 8px; align-items: center; }
    .grow { flex: 1; min-width: 220px; }
  </style>
	<link rel="manifest" href="/manifest.webmanifest">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-title" content="HPC Finder">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<link rel="apple-touch-icon" href="/apple-touch-icon.png">

	<meta name="theme-color" content="#0b1020">
	<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

</head>

<body>
<header>
  <div class="row">
	<strong>HPC Finder TESTI123</strong>

    //<strong>HPC Finder</strong>
    <span class="small">OCM + kartta, Win11 → iPhone (PWA)</span>
  </div>
</header>

<div id="map"></div>

<main>
  <div class="panel">
    <div class="row">
      <input id="dest" class="grow" placeholder="Hae määränpää (esim. 'Oulu', 'Kamppi', 'Tampere')" />
      <button id="searchDest" class="primary">Hae paikka</button>
      <button id="useGPS">Käytä GPS</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <label class="pill">
        Säde (km)
        <select id="radius">
          <option>10</option><option selected>25</option><option>40</option><option>60</option><option>100</option>
        </select>
      </label>

      <label class="pill">
        Min teho (kW)
        <select id="minPower">
          <option>50</option><option>100</option><option selected>150</option><option>200</option><option>250</option>
        </select>
      </label>

      <label class="pill">
        <input type="checkbox" id="onlyOps" />
        Vain ABC / K-Lataus / ST1(Recharge)
      </label>
    </div>

    <div class="row" style="margin-top:10px;">
      <input id="ocmKey" class="grow" placeholder="(Valinnainen) Open Charge Map API key" />
      <button id="fetch" class="primary">Hae laturit</button>
    </div>
    <div class="row" style="margin-top:10px;">
      <input id="fromCity" class="grow" placeholder="Lähtökaupunki (valinnainen, jos käytät GPS:ää)" />
      <label class="pill">
        <input type="checkbox" id="fromGPS" checked />
        Lähtö GPS
      </label>
      <input id="toCity" class="grow" placeholder="Määränpääkaupunki (esim. Oulu)" />
      <button id="btnRoute" class="primary">Hae reitin varrelta (50km/15km)</button>
    </div>


    <div id="status" class="small" style="margin-top:10px; line-height:1.4;"></div>
  </div>

  <div class="panel">
    <div class="row">
      <div class="small warn">
        Hintatieto: näytetään OCM:n “UsageCost” jos löytyy. Ei aina täydellinen/ajantasainen.
      </div>
    </div>
    <div id="list" class="list"></div>
  </div>
</main>

<script>
  // ---------- Kartta ----------
  const map = L.map('map', { zoomControl: true }).setView([60.1699, 24.9384], 10); // Helsinki default
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  let centerMarker = null;
  let markersLayer = L.layerGroup().addTo(map);

  function setCenter(lat, lon, label = "Kohde") {
    if (centerMarker) centerMarker.remove();
    centerMarker = L.marker([lat, lon]).addTo(map).bindPopup(label).openPopup();
    map.setView([lat, lon], 11);
  }
// ---------- Verkko-/operaattoritunnistus (heuristiikka) ----------
// Huom: OCM-data on epätäydellistä. Tunnistetaan verkko myös nimestä/osoitteesta.

function norm(s) {
  return (s || "").toString().toLowerCase().replace(/\s+/g, " ").trim();
}

function detectNetwork({ operatorName, title, addressLine1, town }) {
  const hay = norm([operatorName, title, addressLine1, town].filter(Boolean).join(" | "));

  // ABC
  if (hay.includes("abc") || hay.includes("abc lataus") || hay.includes("abc liikenne")) {
    return "ABC";
  }

  // K-Lataus
  if (hay.includes("k-lataus") || hay.includes("k lataus") || hay.includes("k-lataus")) {
    return "K-Lataus";
  }

  // ST1 / Recharge
  if (hay.includes("st1") || hay.includes("st1 charge") || hay.includes("recharge")) {
    return "ST1/Recharge";
  }

  return "Muu/Unknown";
}

// Kun “vain ABC/K-Lataus/ST1” on päällä, hyväksy myös "todennäköiset" osumat:

// Arvioi todennäköinen HPC silloin kun maxPower puuttuu (0 / null).
// Tällä perusversiolla EI arvata HPC:ksi, ellei data kerro siitä selvästi.
function isLikelyHPC(poi) {
  return false;
}

function isAllowedByHeuristic(network) {
  return network === "ABC" || network === "K-Lataus" || network === "ST1/Recharge";
}

 

  // ---------- UI ----------
  const elDest = document.getElementById('dest');
  const elSearchDest = document.getElementById('searchDest');
  const elUseGPS = document.getElementById('useGPS');
  const elRadius = document.getElementById('radius');
  const elMinPower = document.getElementById('minPower');
  const elOnlyOps = document.getElementById('onlyOps');
  const elFetch = document.getElementById('fetch');
  const elStatus = document.getElementById('status');
  const elList = document.getElementById('list');
  const elKey = document.getElementById('ocmKey');
  const elFromCity = document.getElementById('fromCity');
  const elFromGPS = document.getElementById('fromGPS');
  const elToCity = document.getElementById('toCity');
  const elBtnRoute = document.getElementById('btnRoute');

  let currentCenter = { lat: 60.1699, lon: 24.9384, label: "Helsinki" };

  function setStatus(msg, kind="") {
    elStatus.innerHTML = kind ? `<span class="${kind}">${msg}</span>` : msg;
  }

  // ---------- Paikkahaku (Nominatim / OSM) ----------
  
  function getCurrentPosition() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) return reject(new Error("Geolocation ei ole saatavilla selaimessa."));
      navigator.geolocation.getCurrentPosition(
        pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
        err => reject(new Error(err.message || "GPS-virhe")),
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 30000 }
      );
    });
  }


// iOS/Safari voi estää GPS:n vaikka sivu olisi HTTPS. Tällä varmistetaan, että reittihaku ei kaadu:
async function getStartLocationOrFallback() {
  try {
    const pos = await getCurrentPosition();
    return pos; // {lat, lon}
  } catch (e) {
    return null;
  }
}


async function geocode(query) {
    const url = new URL("https://nominatim.openstreetmap.org/search");
    url.searchParams.set("format", "json");
    url.searchParams.set("q", query);
    url.searchParams.set("limit", "1");

    // Nominatim toivoo asiallisen User-Agentin. Selaimessa ei voi aina muuttaa.
    // Käytetään vain kevyesti.
    const res = await fetch(url.toString(), {
      headers: { "Accept": "application/json" }
    });
    const data = await res.json();
    if (!data || !data.length) return null;
    return {
      lat: parseFloat(data[0].lat),
      lon: parseFloat(data[0].lon),
      label: data[0].display_name
    };
  }

  elSearchDest.addEventListener('click', async () => {
    const q = elDest.value.trim();
    if (!q) return setStatus("Syötä paikka/osoite.", "error");

    setStatus("Haetaan paikka…");
    elSearchDest.disabled = true;
    try {
      const hit = await geocode(q);
      if (!hit) {
        setStatus("Paikkaa ei löytynyt. Kokeile eri hakua.", "error");
        return;
      }
      currentCenter = hit;
      setCenter(hit.lat, hit.lon, "Määränpää");
      setStatus(`Määränpää: ${hit.label}`);
    } catch (e) {
      setStatus("Paikkahaku epäonnistui.", "error");
    } finally {
      elSearchDest.disabled = false;
    }
  });

  // ---------- GPS ----------
  elUseGPS.addEventListener('click', () => {
    if (!navigator.geolocation) return setStatus("Sijainti ei ole käytettävissä selaimessa.", "error");

    setStatus("Haetaan GPS-sijainti…");
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        currentCenter = { lat: latitude, lon: longitude, label: "GPS-sijainti" };
        setCenter(latitude, longitude, "GPS");
        setStatus("Käytetään GPS-sijaintia.");
      },
      () => setStatus("GPS-sijaintia ei saatu. Tarkista luvat.", "error"),
      { enableHighAccuracy: true, timeout: 10000 }
    );
  });

  // ---------- Open Charge Map haku ----------
  async function fetchOCM({ lat, lon, km, key }) {
    const url = new URL("https://api.openchargemap.io/v3/poi/");
    url.searchParams.set("output", "json");
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("distance", km);
    url.searchParams.set("distanceunit", "KM");
    url.searchParams.set("maxresults", "250");
    url.searchParams.set("compact", "false");
    url.searchParams.set("verbose", "true");

    const headers = { "Accept": "application/json" };
    if (key && key.trim().length) headers["X-API-Key"] = key.trim();

    const res = await fetch(url.toString(), { headers });
    if (!res.ok) throw new Error("OCM request failed: " + res.status);
    return await res.json();
  }

async function fetchRouteOSRM(a, b) {
  const url =
    `https://router.project-osrm.org/route/v1/driving/${a.lon},${a.lat};${b.lon},${b.lat}?overview=full&geometries=geojson`;
  const res = await fetch(url, { headers: { Accept: "application/json" } });
  const data = await res.json();
  if (!data?.routes?.length) throw new Error("Reittiä ei saatu (OSRM).");
  return data.routes[0].geometry.coordinates; // [ [lon,lat], ... ]
}

function computeStopsFromPolyline(coordsLonLat, stepKm = 50) {
  const stops = [];
  let acc = 0;

  const first = { lon: coordsLonLat[0][0], lat: coordsLonLat[0][1], label: "Start" };
  stops.push(first);

  let prev = first;

  for (let i = 1; i < coordsLonLat.length; i++) {
    const cur = { lon: coordsLonLat[i][0], lat: coordsLonLat[i][1] };
    acc += haversineKm(prev.lat, prev.lon, cur.lat, cur.lon);

    if (acc >= stepKm) {
      stops.push({ ...cur, label: `Stop ${stops.length}` });
      acc = 0;
    }
    prev = cur;
  }

  const last = { lon: coordsLonLat[coordsLonLat.length - 1][0], lat: coordsLonLat[coordsLonLat.length - 1][1], label: "Destination" };
  stops.push(last);

  return stops;
}


  function getMaxPowerKW(poi) {
  const conns = poi.Connections || [];
  let max = 0;

  for (const c of conns) {
    // 1) Suoraan annettu PowerKW
    if (typeof c.PowerKW === "number" && c.PowerKW > max) {
      max = c.PowerKW;
      continue;
    }
function toNum(x) {
  if (typeof x === "number") return x;
  if (typeof x === "string") {
    const v = parseFloat(x.replace(",", "."));
    return Number.isFinite(v) ? v : NaN;
  }
  return NaN;
}

// UUSI versio: ylikirjoittaa aiemman getMaxPowerKW-funktion
function getMaxPowerKW(poi) {
  const conns = poi.Connections || [];
  let max = 0;

  for (const c of conns) {
    const pkw = toNum(c.PowerKW);
    if (Number.isFinite(pkw) && pkw > max) {
      max = pkw;
      continue;
    }

    const v = toNum(c.Voltage);
    const a = toNum(c.Amps);
    const phases = toNum(c.Phases);
    const ph = Number.isFinite(phases) && phases > 0 ? phases : 1;

    if (Number.isFinite(v) && Number.isFinite(a)) {
      const kw = (v * a * ph) / 1000.0;
      if (kw > max) max = kw;
    }
  }

  return max;
}

    // 2) Laske arviolta Voltage * Amps (ja tarvittaessa phases)
    const v = (typeof c.Voltage === "number") ? c.Voltage : null;
    const a = (typeof c.Amps === "number") ? c.Amps : null;
    const phases = (typeof c.Phases === "number" && c.Phases > 0) ? c.Phases : 1;

    if (v && a) {
      // DC: phases ei yleensä ole relevantti, mutta ei haittaa jos se puuttuu
      const kw = (v * a * phases) / 1000.0;
      if (kw > max) max = kw;
    }
  }

  return max;
}


  function normalizeCost(cost) {
    if (!cost) return "";
    return String(cost).trim();
  }

  function buildNavigateLinks(lat, lon, name) {
    const appleMaps = `https://maps.apple.com/?daddr=${encodeURIComponent(lat + "," + lon)}&dirflg=d`;
    // Google Maps universal link (works if installed, else browser)
    const googleMaps = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(lat + "," + lon)}&travelmode=driving`;
    return { appleMaps, googleMaps };
  }

  function clearResults() {
    markersLayer.clearLayers();
    elList.innerHTML = "";
  }

  function renderResults(items) {
    clearResults();

    if (!items.length) {
      setStatus("Ei osumia näillä suodattimilla. Nosta sädettä tai laske minimitehoa.", "warn");
      return;
    }

    for (const it of items) {
const minPower = parseFloat(elMinPower.value || "0");

     // const isConfirmed = it.maxPower >= minPower;
// const isLikely = (!isConfirmed && it.maxPower === 0 && (typeof isLikelyHPC === "function" ? isLikelyHPC(it.poi) : false));

//const color = isConfirmed ? "green" : (isLikely ? "orange" : "gray");
// *
 //const minPowerNow = parseFloat((document.getElementById("minPower")?.value || "0"));

 //const filtered = results.filter(it =>
   //it.maxPower >= minPowerNow ||
   //(it.maxPower === 0 && (typeof isLikelyHPC === "function" ? isLikelyHPC(it.poi) : false))
 //);
// *

  const minPowerNow = parseFloat((document.getElementById("minPower")?.value || "0").toString());

  const isConfirmed = Number(it.maxPower) >= minPowerNow;
  const isLikely = (!isConfirmed && Number(it.maxPower) === 0 && (typeof isLikelyHPC === "function" ? isLikelyHPC(it.poi) : false));

  const color = isConfirmed ? "green" : (isLikely ? "orange" : "gray");

  const m = L.circleMarker([it.lat, it.lon], {
    radius: 8,
    weight: 2,
    color: color,
    fillColor: color,
    fillOpacity: 0.9
  }).addTo(map);
  
// **

      const cost = it.usageCost ? `<br><strong>Hinta:</strong> ${escapeHtml(it.usageCost)}` : "";
      m.bindPopup(`<strong>${escapeHtml(it.title)}</strong><br>${escapeHtml(it.operatorName || "Operator: ?")}<br><strong>${it.maxPower} kW</strong>${cost}`);
    }

    const cards = items.map(it => {
      const { appleMaps, googleMaps } = buildNavigateLinks(it.lat, it.lon, it.title);
      return `
        <div class="card">
          <h3>${escapeHtml(it.title)}</h3>
          <div class="meta">
  	<span class="pill">${escapeHtml(it.network || "Muu/Unknown")}</span>
 	 <span class="pill">${escapeHtml(it.operatorName || "Operator: ?")}</span>
 	 <span class="pill">${it.maxPower} kW</span>
 	 <span class="pill">${it.distanceKm.toFixed(1)} km</span>
	</div>

          <div class="small" style="margin-top:8px;">
          //  ${it.usageCost ? `Hinta (OCM): <strong>${escapeHtml(it.usageCost)}</strong>` : `<span class="warn">Hinta: (ei tietoa OCM:ssä)</span>`}
${it.usageCost
  ? "Hinta (OCM): <strong>" + escapeHtml(it.usageCost) + "</strong>"
  : '<span class="warn">Hinta: (ei tietoa OCM:ssä)</span>'}

          </div>
          <div class="actions">
            <a href="${appleMaps}" target="_blank" rel="noopener">
              <button>Navigoi Apple Maps</button>
            </a>
            <a href="${googleMaps}" target="_blank" rel="noopener">
              <button>Navigoi Google Maps</button>
            </a>
            <button onclick="window.__centerOn(${it.lat},${it.lon})">Näytä kartalla</button>
          </div>
        </div>
      `;
    }).join("");

    elList.innerHTML = cards;
    setStatus(`Löytyi ${items.length} sopivaa HPC-laturia. (Kohde: ${currentCenter.label})`);
  }

  // Quick distance calc (Haversine)
  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
      Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  window.__centerOn = (lat, lon) => map.setView([lat, lon], 13);

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  elFetch.addEventListener('click', async () => {
    const km = parseFloat(elRadius.value);
    const minPower = parseFloat(elMinPower.value);
    const onlyOps = elOnlyOps.checked;
    const key = elKey.value;

    setStatus("Haetaan latureita Open Charge Mapista…");
    elFetch.disabled = true;

    try {
      const pois = await fetchOCM({ lat: currentCenter.lat, lon: currentCenter.lon, km, key });

	console.log("DEBUG OCM pois.length =", pois.length, "km=", km, "minPower=", minPower, "onlyOps=", onlyOps);

	setStatus(`DEBUG: OCM palautti ${pois.length} POI:ta`, "");

      // Map + filter
      const results = (pois || []).map(p => {
        const ai = p.AddressInfo || {};
        const lat = ai.Latitude, lon = ai.Longitude;
        const title = ai.Title || `OCM ${p.ID}`;
        const operatorName = (p.OperatorInfo && p.OperatorInfo.Title) || "";
	const addressLine1 = ai.AddressLine1 || "";
	const town = ai.Town || "";
	const network = detectNetwork({ operatorName, title, addressLine1, town });

        const maxPower = getMaxPowerKW(p);
        const usageCost = normalizeCost(p.UsageCost);
        const distanceKm = haversineKm(currentCenter.lat, currentCenter.lon, lat, lon);

        return { poi: p, id: p.ID, title, lat, lon, operatorName, addressLine1, town, network, maxPower, usageCost, distanceKm };

      }).filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));

      	const filtered = results
  	.filter(x => x.maxPower >= minPower && (!onlyOps || isAllowedByHeuristic(x.network)))
 	.sort((a,b) => {
    	const aHas = a.usageCost && a.usageCost.length > 0;
    	const bHas = b.usageCost && b.usageCost.length > 0;
    	if (aHas !== bHas) return aHas ? -1 : 1;
    	return a.distanceKm - b.distanceKm;
  	});
	console.log("DEBUG filtered.length =", filtered.length);


	// const filtered = results
	// setStatus(`DEBUG: OCM palautti ${pois.length} → suodattimien jälkeen ${filtered.length}`, "");
        // .filter(x => x.maxPower >= minPower)
        // .filter(x => !onlyOps || isAllowedOperator(x.operatorName))
        // .sort((a,b) => {
          // Sort: known cost first, then closest
          // const aHas = a.usageCost.length > 0;
          // const bHas = b.usageCost.length > 0;
         // if (aHas !== bHas) return aHas ? -1 : 1;
         // return a.distanceKm - b.distanceKm;
       // });

      renderResults(filtered);
    } catch (e) {
      setStatus("OCM-haku epäonnistui. Kokeile lisätä API key tai yritä myöhemmin.", "error");
    } finally {
      elFetch.disabled = false;
    }
  });

elBtnRoute.addEventListener('click', async () => {
  const fromName = (elFromCity.value || "").trim();
  const toName = (elToCity.value || "").trim();
  const key = elKey.value;

  if (!toName) {
    setStatus("Anna määränpääkaupunki.", "warn");
    return;
  }

  elBtnRoute.disabled = true;

  try {
    setStatus("Haetaan lähtö ja määränpää…");
    let from;
    if (elFromGPS && elFromGPS.checked) {
      const gps = await getStartLocationOrFallback();
      if (gps) {
        from = { lat: gps.lat, lon: gps.lon, label: "GPS" };
      } else {
        // GPS ei onnistunut → käytä lähtökaupunkia, jos annettu
        if (!fromName) {
          setStatus("GPS-sijaintia ei saatu. Anna lähtökaupunki tai tarkista sijaintiluvat.", "warn");
          return;
        }
        setStatus("GPS ei onnistunut – käytetään lähtökaupunkia…", "warn");
        from = await geocode(fromName);
      }
    } else {
      if (!fromName) {
        setStatus("Anna lähtökaupunki tai valitse Lähtö GPS.", "warn");
        return;
      }
      from = await geocode(fromName);
    }

    const to = await geocode(toName);

    if (!from || !to) {
      setStatus("Kaupunkeja ei löytynyt. Kokeile tarkempaa nimeä.", "error");
      return;
    }

    setStatus("Haetaan reitti (OSRM)…");
    const poly = await fetchRouteOSRM(from, to);
    const stops = computeStopsFromPolyline(poly, 50);

    setStatus(`Stoppeja ${stops.length}. Haetaan latureita (15 km / stop)…`);

    const byId = new Map();

    for (let i = 0; i < stops.length; i++) {
      const s = stops[i];
      setStatus(`Haku ${i + 1}/${stops.length}: ${s.label}`);

      const pois = await fetchOCM({ lat: s.lat, lon: s.lon, km: 15, key });

      for (const p of (pois || [])) {
        if (p?.ID && !byId.has(p.ID)) byId.set(p.ID, p);
      }
    }

    const merged = [...byId.values()];

    const results = (merged || []).map(p => {
      const ai = p.AddressInfo || {};
      const lat = ai.Latitude, lon = ai.Longitude;
      const title = ai.Title || `OCM ${p.ID}`;
      const operatorName = (p.OperatorInfo && p.OperatorInfo.Title) || "";
      const addressLine1 = ai.AddressLine1 || "";
      const town = ai.Town || "";
      const network = detectNetwork(p);

      const maxPower = getMaxPowerKW(p);
      const usageCost = normalizeCost(p.UsageCost);

      const distanceKm = haversineKm(from.lat, from.lon, lat, lon);

      return { poi: p, id: p.ID, title, lat, lon, operatorName, addressLine1, town, network, maxPower, usageCost, distanceKm };
    }).filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));

    const filtered = results
      .filter(x => !elOnlyOps.checked || isAllowedByHeuristic(x.network))
      .sort((a, b) => a.distanceKm - b.distanceKm);

    map.fitBounds(stops.map(s => [s.lat, s.lon]), { padding: [20, 20] });

    renderResults(filtered);
    setStatus(`Reittihaku valmis: ${filtered.length} pistettä (uniikit).`);
  } catch (e) {
    console.error(e);
    setStatus("Reittihaku epäonnistui: " + (e?.message || e), "error");
  } finally {
    elBtnRoute.disabled = false;
  }
});


  // Default center marker
  setCenter(currentCenter.lat, currentCenter.lon, "Oletuskeskipiste");
  setStatus("Vinkki: hae määränpää → Hae laturit. Tai paina Käytä GPS.");
</script>

<!-- Minimal manifest inline fallback (Safari needs a file, but this helps) -->
<script>
  // Create a simple manifest file on the fly if you host it properly with a real file.
</script>

</body>
</html>
